# Hash Map

## 原理

> 1. 有一个哈希函数 通过将 key 转换为 hash 值
> 2. 有了 Hash 值之后就可以通过这个值作为数组下表将数据存储在数组中，这样就可以快速访问到数据

## 哈希函数

> 1. 通过 Key 生成 HashCode 的函数
> 2. 可以根据具体数据情况来编写更高效更准确的哈希函数
> 3. 追求 简单高效 分布均匀(可以减少哈希冲突程度)

## 装载因子

> 1. 代表哈希表满载程度，越大哈希表空闲位置越少
> 2. 装载因子越大，空闲位置越少，哈希冲突概率就会越高，插入，删除，查找 的性能就会随之降低
> 3. 所以哈希表可以设置最大装载因子，即在装载因子达到这个值时，哈希表就会进行扩容

## 哈希冲突

> 不同 Key 通过哈希函数可能会生成同样的值，这就是哈希冲突

> 如何解决哈希冲突:
> 1. 开放寻址法
>> 1. 遇到冲突时则按照一定规则寻找下一个空的位置插入数据
>> 2. 查询数据时根据 HashCode 查到的数据如果和要查的数据不符合，则继续向后查找(查找方式也分多种)，如果遇到空闲位置则终止，说明不存在该元素
>> 3. 这时就会出现一个问题，如果 Hash 表中途有删除数据，按这种方式查找数据就会出问题，所以还需要对删除数据的位置进行标记 deleted
> 2. 链表法
>> 1. 哈希表每一个位置对应一个链表，如果出现哈希冲突则往链表中一个个插入数据
>> 2. 这种方式有一个问题，如果 Hash 函数生成的 HashCode 有很多相同值， 就会使整个哈希表变成近似一个链表，这时访问元素的时间复杂度就会从 O(1) 变成 O(n) 称为 哈希碰撞


> 总结
>> 1. 数据量较小 装载因子不高 的哈希表适合使用开放寻址法
>> 2. 工业级哈希表 Java HashMap 中采用链表法解决哈希冲突，且在链表过长时会引入红黑树，避免哈希碰撞 且在链表由长变短时，会从红黑树转化为链表，因为数据量小时红黑树的效率反而不如链表

## 扩容问题

> 1. 因为哈希表是用数组实现的，所以再扩容时也要做大量的拷贝
> 2. 如果在创建哈希表时可以确定最大容量时，可以提前指定哈希表的容量， 这里之前踩过坑，之前项目里有个数据用了哈希表频繁插入造成大量 gc C# 的哈希表无法设置初始容量，但是可以通过反射实现
     https://stackoverflow.com/questions/6771917/why-cant-i-preallocate-a-hashsett
> 3. 哈希表扩容也有一定策略，如在扩容时先不一次性拷贝所有数据，先申请更大的空间，在每次插入时同时搬运一个数据 这样就把拷贝操作分散到多次插入操作中，避免一次插入操作产生大量性能消耗，造成用户可感知的卡顿等
     

